# TypeScript编码规范与最佳实践

<cite>
**本文档引用的文件**
- [tsconfig.json](file://tsconfig.json)
- [package.json](file://package.json)
- [src/index.ts](file://src/index.ts)
- [src/models/types.ts](file://src/models/types.ts)
- [src/services/TronRPCService.ts](file://src/services/TronRPCService.ts)
- [src/middleware/auth.ts](file://src/middleware/auth.ts)
- [src/services/AuthService.ts](file://src/services/AuthService.ts)
- [src/models/UserModel.ts](file://src/models/UserModel.ts)
- [src/routes/auth.ts](file://src/routes/auth.ts)
- [src/routes/blocks.ts](file://src/routes/blocks.ts)
- [src/config/index.ts](file://src/config/index.ts)
- [test.js](file://test.js)
</cite>

## 目录
1. [项目概述](#项目概述)
2. [TypeScript配置规范](#typescript配置规范)
3. [命名约定](#命名约定)
4. [代码格式化与类型定义](#代码格式化与类型定义)
5. [错误处理最佳实践](#错误处理最佳实践)
6. [异步编程规范](#异步编程规范)
7. [日志记录策略](#日志记录策略)
8. [单元测试原则](#单元测试原则)
9. [代码审查清单](#代码审查清单)
10. [JSDoc注释规范](#jsdoc注释规范)
11. [性能优化建议](#性能优化建议)
12. [总结](#总结)

## 项目概述

本项目是一个基于TypeScript的TRON波场网络区块链数据统计后台管理系统，采用现代化的TypeScript开发规范，注重代码质量和可维护性。项目结构清晰，模块化程度高，涵盖了完整的后端开发最佳实践。

## TypeScript配置规范

### 严格模式配置

项目在`tsconfig.json`中启用了严格的TypeScript编译选项：

```json
{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

**严格模式的重要性：**
- **类型检查增强**：启用所有严格类型检查选项
- **模块互操作**：支持CommonJS和ES模块的互操作
- **跳过库检查**：提高编译速度，避免第三方库的类型检查问题

### 编译目标配置

```json
{
  "compilerOptions": {
    "target": "es6",
    "module": "commonjs",
    "moduleResolution": "node"
  }
}
```

**配置说明：**
- 使用ES6作为目标版本，支持现代JavaScript特性
- 采用CommonJS模块系统，兼容Node.js环境
- 启用Node.js模块解析策略，支持npm包解析

**章节来源**
- [tsconfig.json](file://tsconfig.json#L1-L14)

## 命名约定

### 变量命名规范

项目严格遵循驼峰式命名法：

```typescript
// ✅ 推荐：变量使用驼峰式命名
const userName = 'admin';
const blockNumber = 123456;
const pollingInterval = 3000;

// ❌ 不推荐：使用下划线或大写字母开头
const _userName = 'admin'; // 下划线前缀
const UserName = 'admin';  // PascalCase用于类名
```

### 类名命名规范

项目使用帕斯卡式（PascalCase）命名类：

```typescript
// ✅ 推荐：类名使用帕斯卡式命名
class TronRPCService {
  // 类实现
}

class AuthService {
  // 类实现
}

// ✅ 推荐：接口使用帕斯卡式命名
interface BlockInfo {
  id?: number;
  block_number: number;
  block_hash: string;
  timestamp: number;
}

// ✅ 推荐：枚举使用帕斯卡式命名
enum TimeRange {
  OneDay = '1day',
  OneWeek = '1week',
  OneMonth = '1month'
}
```

### 函数和方法命名

```typescript
// ✅ 推荐：函数使用动词开头的驼峰式命名
async function getLatestBlock(): Promise<BlockInfo> {
  // 实现
}

function parseBlockHash(hash: string): number {
  // 实现
}

// ✅ 推荐：私有方法以下划线开头
private async _executePolling(): Promise<void> {
  // 实现
}
```

**章节来源**
- [src/services/TronRPCService.ts](file://src/services/TronRPCService.ts#L1-L50)
- [src/models/types.ts](file://src/models/types.ts#L1-L60)

## 代码格式化与类型定义

### 接口与类型定义

项目广泛使用TypeScript接口和类型别名来确保类型安全：

```typescript
// ✅ 推荐：使用接口定义复杂的数据结构
export interface BlockInfo {
  id?: number;
  block_number: number;
  block_hash: string;
  timestamp: number;
  last_digit: number;
  is_odd: boolean;
  created_at?: string;
}

// ✅ 推荐：使用类型别名简化复杂类型
export type ApiResponse<T = any> = {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
};

// ✅ 推荐：使用泛型增强类型灵活性
export async function create<T>(model: T): Promise<number> {
  // 实现
}
```

### 避免使用any类型

项目严格避免使用`any`类型，确保类型安全：

```typescript
// ✅ 推荐：明确指定类型
async function getUserById(id: number): Promise<User | null> {
  const result = await database.get('SELECT * FROM users WHERE id = ?', [id]);
  return result || null;
}

// ✅ 推荐：使用联合类型处理多种可能性
function parseResponse(response: any): BlockInfo | null {
  try {
    // 解析逻辑
    return parsedData;
  } catch (error) {
    console.error('解析失败:', error);
    return null;
  }
}

// ✅ 推荐：使用类型断言而非any
const decoded = jwt.verify(token, secret) as JWTPayload;
```

### 类型守卫与类型保护

```typescript
// ✅ 推荐：使用类型守卫确保类型安全
function isBlockInfo(obj: any): obj is BlockInfo {
  return obj &&
         typeof obj.block_number === 'number' &&
         typeof obj.block_hash === 'string';
}

// ✅ 推荐：使用类型保护处理联合类型
function handleApiResponse(response: ApiResponse): void {
  if (response.success) {
    // 在这里，TypeScript知道response.data存在
    console.log('数据:', response.data);
  } else {
    // 在这里，TypeScript知道response.error存在
    console.error('错误:', response.error);
  }
}
```

**章节来源**
- [src/models/types.ts](file://src/models/types.ts#L1-L60)
- [src/services/TronRPCService.ts](file://src/services/TronRPCService.ts#L100-L150)

## 错误处理最佳实践

### try-catch使用规范

项目采用统一的错误处理策略：

```typescript
// ✅ 推荐：在关键业务逻辑中使用try-catch
public async getLatestBlock(): Promise<BlockInfo> {
  try {
    const response = await this.makeHttpRequest('/wallet/getnowblock', {});
    return this.parseTronBlockResponse(response);
  } catch (error: any) {
    console.error('获取最新区块失败:', error?.message);
    throw new Error(`RPC请求失败: ${error?.message}`);
  }
}

// ✅ 推荐：在异步函数中捕获异常
private async executePolling(): Promise<void> {
  try {
    const latestBlock = await this.getLatestBlock();
    
    if (this.onBlockCallback) {
      this.onBlockCallback(latestBlock);
    }
    
    this.consecutiveErrors = 0;
    this.lastBlockTime = Date.now();

  } catch (error: any) {
    this.consecutiveErrors++;
    console.error(`RPC轮询错误 (连续第${this.consecutiveErrors}次):`, error?.message);
    
    if (this.consecutiveErrors >= 10) {
      console.error('连续错误次数过多，请检查TRON网络连接');
    }
  }
}
```

### 自定义错误类型

```typescript
// ✅ 推荐：创建专门的错误类
class AuthenticationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthenticationError';
  }
}

class ValidationError extends Error {
  constructor(public field: string, message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

// ✅ 推荐：在业务逻辑中抛出特定错误
async function createUser(userData: CreateUserParams): Promise<User> {
  if (!userData.username) {
    throw new ValidationError('username', '用户名不能为空');
  }
  
  if (!userData.password) {
    throw new ValidationError('password', '密码不能为空');
  }
  
  try {
    const hashedPassword = await bcrypt.hash(userData.password, 10);
    // 创建用户逻辑
  } catch (error) {
    throw new AuthenticationError('密码加密失败');
  }
}
```

### 中间件错误处理

```typescript
// ✅ 推荐：统一的错误处理中间件
export const errorHandler = (
  error: Error,
  req: Request,
  res: Response<ApiResponse>,
  next: NextFunction
): void => {
  console.error('未处理的错误:', error);

  // 特定错误类型处理
  if (error.message.includes('SQLITE')) {
    res.status(500).json({
      success: false,
      error: '数据库操作失败'
    });
    return;
  }

  if (error.name === 'JsonWebTokenError') {
    res.status(401).json({
      success: false,
      error: '无效的访问令牌'
    });
    return;
  }

  // 默认错误处理
  res.status(500).json({
    success: false,
    error: '服务器内部错误'
  });
};
```

**章节来源**
- [src/services/TronRPCService.ts](file://src/services/TronRPCService.ts#L60-L120)
- [src/middleware/auth.ts](file://src/middleware/auth.ts#L40-L80)

## 异步编程规范

### async/await使用规范

项目全面采用async/await语法，避免回调地狱：

```typescript
// ✅ 推荐：使用async/await处理异步操作
public async startPolling(callback: (blockInfo: BlockInfo) => void): void {
  if (this.isPolling) {
    console.warn('RPC轮询已在运行中');
    return;
  }

  this.onBlockCallback = callback;
  this.isPolling = true;
  this.consecutiveErrors = 0;

  console.log(`开始TRON RPC轮询，间隔: ${this.pollingInterval}ms`);

  // 立即执行一次
  await this._executePolling();

  // 设置定时器
  this.pollingTimer = setInterval(async () => {
    await this._executePolling();
  }, this.pollingInterval);
}

// ✅ 推荐：批量异步操作使用Promise.all
router.get('/stats', authenticateToken, async (req, res) => {
  try {
    const [todayStats, currentBlock, hourlyStats] = await Promise.all([
      BlockModel.getTodayStats(),
      BlockModel.getLatest(),
      BlockModel.getTodayHourlyStats()
    ]);

    res.json({
      success: true,
      data: {
        todayTotal: todayStats.total,
        todayOdd: todayStats.odd,
        todayEven: todayStats.even,
        hourlyStats: hourlyStats,
        currentBlock: currentBlock ? {
          number: currentBlock.block_number,
          hash: currentBlock.block_hash,
          timestamp: currentBlock.timestamp,
          lastDigit: currentBlock.last_digit,
          isOdd: currentBlock.is_odd
        } : null
      }
    });

  } catch (error) {
    console.error('获取统计数据错误:', error);
    res.status(500).json({
      success: false,
      error: '服务器内部错误'
    });
  }
});
```

### 错误传播与处理

```typescript
// ✅ 推荐：正确的错误传播方式
public async testConnection(): Promise<{ success: boolean; latency?: number; error?: string }> {
  const startTime = Date.now();
  
  try {
    await this.getLatestBlock();
    const latency = Date.now() - startTime;
    
    return {
      success: true,
      latency
    };
  } catch (error: any) {
    return {
      success: false,
      error: error?.message || '未知错误'
    };
  }
}

// ✅ 推荐：在构造函数中进行异步初始化
public async start(): Promise<void> {
  try {
    // 初始化数据库
    await database.connect();
    await database.initializeTables();
    
    // 创建默认管理员账户
    await this.createDefaultAdmin();
    
    // 启动TRON数据采集
    await this.blockDataService.start();
    
    // 启动Express服务器
    this.app.listen(config.port, () => {
      console.log(`🚀 Point-Tron服务器启动成功`);
      console.log(`📡 服务地址: http://localhost:${config.port}`);
    });
    
  } catch (error) {
    console.error('应用启动失败:', error);
    process.exit(1);
  }
}
```

**章节来源**
- [src/services/TronRPCService.ts](file://src/services/TronRPCService.ts#L30-L80)
- [src/routes/blocks.ts](file://src/routes/blocks.ts#L10-L50)
- [src/index.ts](file://src/index.ts#L80-L120)

## 日志记录策略

### 结构化日志记录

项目采用结构化的日志记录方式：

```typescript
// ✅ 推荐：使用console.log记录关键信息
console.log(`开始TRON RPC轮询，间隔: ${this.pollingInterval}ms`);
console.log(`尝试第${attempt}次请求: ${url}`);
console.log(`等待${delay}ms后重试...`);

// ✅ 推荐：使用warn记录警告信息
console.warn(`请求尝试${attempt}失败:`, error?.message);
console.warn(`区块哈希中未找到数字: ${hash}`);

// ✅ 推荐：使用error记录错误信息
console.error('应用启动失败:', error);
console.error('创建默认管理员失败:', error);
console.error(`RPC轮询错误 (连续第${this.consecutiveErrors}次):`, error?.message);
```

### 请求日志中间件

```typescript
// ✅ 推荐：实现请求日志中间件
export const requestLogger = (req: Request, res: Response, next: NextFunction): void => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(
      `${req.method} ${req.path} - ${res.statusCode} - ${duration}ms - ${req.ip}`
    );
  });
  
  next();
};
```

### 调试和监控

```typescript
// ✅ 推荐：在关键位置添加调试信息
private async _executePolling(): Promise<void> {
  try {
    const latestBlock = await this.getLatestBlock();
    
    if (this.onBlockCallback) {
      this.onBlockCallback(latestBlock);
    }
    
    this.consecutiveErrors = 0;
    this.lastBlockTime = Date.now();
    console.log('区块轮询成功完成');

  } catch (error: any) {
    this.consecutiveErrors++;
    console.error(`RPC轮询错误 (连续第${this.consecutiveErrors}次):`, error?.message);
    
    if (this.consecutiveErrors >= 10) {
      console.error('连续错误次数过多，请检查TRON网络连接');
    }
  }
}
```

**章节来源**
- [src/services/TronRPCService.ts](file://src/services/TronRPCService.ts#L70-L120)
- [src/middleware/auth.ts](file://src/middleware/auth.ts#L70-L85)

## 单元测试原则

### 测试文件组织

虽然项目目前主要使用集成测试，但建议采用以下测试组织结构：

```typescript
// ✅ 推荐：测试文件命名规范
// src/services/__tests__/TronRPCService.test.ts
// src/models/__tests__/UserModel.test.ts
// src/routes/__tests__/auth.test.ts

// ✅ 推荐：测试用例结构
describe('TronRPCService', () => {
  let service: TronRPCService;
  
  beforeEach(() => {
    service = new TronRPCService();
  });
  
  describe('getLatestBlock', () => {
    it('应该返回有效的区块信息', async () => {
      // 测试实现
    });
    
    it('应该在错误时正确处理', async () => {
      // 测试实现
    });
  });
});
```

### 测试工具使用

项目使用Jest进行单元测试：

```json
{
  "scripts": {
    "test": "jest"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "@types/jest": "^29.5.8"
  }
}
```

### 测试最佳实践

```typescript
// ✅ 推荐：使用模拟和存根
import { jest } from '@jest/globals';

describe('AuthService', () => {
  it('应该正确生成JWT令牌', () => {
    const user = { id: 1, username: 'test' };
    const token = AuthService.generateToken(user);
    
    expect(token).toBeDefined();
    expect(typeof token).toBe('string');
  });
  
  it('应该验证有效的JWT令牌', () => {
    const user = { id: 1, username: 'test' };
    const token = AuthService.generateToken(user);
    const decoded = AuthService.verifyToken(token);
    
    expect(decoded).toBeDefined();
    expect(decoded?.userId).toBe(1);
  });
});
```

**章节来源**
- [package.json](file://package.json#L8-L12)
- [test.js](file://test.js#L1-L50)

## 代码审查清单

### 代码质量检查

以下是项目遵循的主要代码审查标准：

1. **类型安全性**
   - [ ] 所有函数都有明确的返回类型
   - [ ] 避免使用`any`类型
   - [ ] 正确使用接口和类型别名
   - [ ] 使用类型守卫确保类型安全

2. **错误处理**
   - [ ] 关键操作都包含try-catch
   - [ ] 错误信息具有描述性
   - [ ] 特定错误类型得到适当处理
   - [ ] 资源清理在finally块中完成

3. **异步编程**
   - [ ] 使用async/await而非回调
   - [ ] 正确处理并发操作
   - [ ] 避免Promise滥用
   - [ ] 合理使用Promise.all

4. **命名规范**
   - [ ] 变量使用驼峰式命名
   - [ ] 类使用帕斯卡式命名
   - [ ] 接口使用帕斯卡式命名
   - [ ] 私有方法以下划线开头

5. **代码结构**
   - [ ] 函数长度不超过50行
   - [ ] 类职责单一
   - [ ] 避免重复代码
   - [ ] 合理使用设计模式

### 代码审查工具

```json
{
  "scripts": {
    "dev": "ts-node src/index.ts",
    "build": "tsc && mkdir -p dist/views && cp src/views/*.ejs dist/views/"
  },
  "devDependencies": {
    "typescript": "^5.9.2",
    "ts-node": "^10.9.1"
  }
}
```

**章节来源**
- [package.json](file://package.json#L1-L39)

## JSDoc注释规范

### 函数注释

```typescript
/**
 * 从请求头中提取JWT令牌
 * 
 * @param authHeader - Authorization头部字符串，格式为"Bearer token"或直接token
 * @returns 提取的令牌字符串，如果无法提取则返回null
 * 
 * @example
 * const token = AuthService.extractTokenFromHeader('Bearer abc123');
 * console.log(token); // 'abc123'
 */
static extractTokenFromHeader(authHeader: string | undefined): string | null {
  if (!authHeader) {
    return null;
  }

  const parts = authHeader.split(' ');
  if (parts.length === 2 && parts[0] === 'Bearer') {
    return parts[1];
  }

  return authHeader;
}
```

### 类注释

```typescript
/**
 * TRON区块链RPC服务
 * 
 * 负责与TRON网络进行交互，获取区块信息和执行相关操作
 * 
 * @example
 * const rpcService = new TronRPCService();
 * const block = await rpcService.getLatestBlock();
 * console.log(block.block_number);
 */
export class TronRPCService {
  /**
   * 启动区块轮询
   * 
   * @param callback - 当检测到新区块时调用的回调函数
   */
  public startPolling(callback: (blockInfo: BlockInfo) => void): void {
    // 实现
  }
}
```

### 接口注释

```typescript
/**
 * 区块信息接口
 * 
 * 描述TRON区块链区块的基本属性
 */
export interface BlockInfo {
  /** 区块唯一标识符 */
  id?: number;
  
  /** 区块高度 */
  block_number: number;
  
  /** 区块哈希值 */
  block_hash: string;
  
  /** 时间戳 */
  timestamp: number;
  
  /** 最后一位数字 */
  last_digit: number;
  
  /** 是否为奇数 */
  is_odd: boolean;
  
  /** 创建时间 */
  created_at?: string;
}
```

### 参数和返回值注释

```typescript
/**
 * 验证用户凭据
 * 
 * @param username - 用户名
 * @param password - 密码
 * @returns 如果验证成功返回用户对象，否则返回null
 * 
 * @throws {Error} 当数据库查询失败时抛出错误
 */
static async verifyPassword(username: string, password: string): Promise<User | null> {
  const user = await this.findByUsername(username);
  if (!user) {
    return null;
  }

  const isValidPassword = await bcrypt.compare(password, user.password);
  if (!isValidPassword) {
    return null;
  }

  return user;
}
```

**章节来源**
- [src/services/AuthService.ts](file://src/services/AuthService.ts#L20-L40)
- [src/services/TronRPCService.ts](file://src/services/TronRPCService.ts#L15-L35)
- [src/models/types.ts](file://src/models/types.ts#L1-L20)

## 性能优化建议

### 内存管理

```typescript
// ✅ 推荐：及时清理定时器和事件监听器
public stopPolling(): void {
  if (this.pollingTimer) {
    clearInterval(this.pollingTimer);
    this.pollingTimer = null;
  }
  this.isPolling = false;
  this.onBlockCallback = null;
  console.log('TRON RPC轮询已停止');
}

// ✅ 推荐：在应用关闭时清理资源
public async shutdown(): Promise<void> {
  console.log('正在关闭应用...');
  
  // 停止TRON数据采集
  this.blockDataService.stop();
  
  // 关闭数据库连接
  await database.close();
  
  console.log('应用已安全关闭');
  process.exit(0);
}
```

### 并发控制

```typescript
// ✅ 推荐：使用速率限制防止过度请求
const rateLimitMap = new Map<string, { count: number; resetTime: number }>();

export const rateLimit = (maxRequests: number = 100, windowMs: number = 60000) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
    const now = Date.now();
    
    const clientData = rateLimitMap.get(clientIp);
    
    if (!clientData || now > clientData.resetTime) {
      // 重置或初始化
      rateLimitMap.set(clientIp, {
        count: 1,
        resetTime: now + windowMs
      });
      next();
      return;
    }
    
    if (clientData.count >= maxRequests) {
      res.status(429).json({
        success: false,
        error: '请求过于频繁，请稍后再试'
      });
      return;
    }
    
    clientData.count++;
    next();
  };
};
```

### 缓存策略

```typescript
// ✅ 推荐：实现简单的缓存机制
class CacheManager {
  private cache = new Map<string, { data: any; expires: number }>();
  
  public set(key: string, data: any, ttl: number = 300000): void {
    this.cache.set(key, {
      data,
      expires: Date.now() + ttl
    });
  }
  
  public get<T>(key: string): T | null {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expires) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
}
```

**章节来源**
- [src/services/TronRPCService.ts](file://src/services/TronRPCService.ts#L45-L60)
- [src/middleware/auth.ts](file://src/middleware/auth.ts#L120-L170)
- [src/index.ts](file://src/index.ts#L140-L163)

## 总结

本项目展示了现代TypeScript开发的最佳实践，涵盖了从基础配置到高级特性的各个方面。通过遵循这些编码规范和最佳实践，开发者可以：

1. **提高代码质量**：通过严格的类型检查和错误处理，减少运行时错误
2. **增强可维护性**：清晰的命名约定和结构化代码使项目易于理解和维护
3. **提升开发效率**：统一的规范减少了团队协作中的沟通成本
4. **确保长期稳定性**：良好的错误处理和资源管理策略保证了系统的稳定运行

建议团队在日常开发中持续关注这些规范，并根据项目发展需要适时调整和完善。同时，鼓励团队成员积极参与代码审查，共同维护高质量的代码库。